{"user_level": "Beginner", "learning_period": "1 Week", "user_goals": "Being able to understand the content present in the PDF based on Cryptography", "topics": "Cryptography and Network Security", "pdf_texts": " \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nModule -1 \nClassical Encryption Techniques: Symmetric Cipher Model, Cryptography, Cryptanalysis \nand BruteForce  Attack,  Substitution  Techniques,  Caesar  Cipher,  Monoalphabetic  Cipher,  \nPlayfair  Cipher,  Hill Cipher,  Polyalphabetic  Cipher,  One Time  Pad.  \nBlock  Ciphers  and the Data  Encryption  Standard:  Traditional  block  Cipher  structure,  \nStream  Ciphers  and Block Ciphers, Motivation for the Feistel Cipher structure, the Feistel \nCipher, The data encryption  standard, DES encryption, DES decryption, A DES example, \nresults, the avalanche effect, the strength of  DES, the use of 56 -Bit Keys, the nature of the \nDES algorithm, timing attacks, Block cipher design  principles, number of rounds, design of \nfunction F, key schedule algorithm        \n  \n \nSYMMETRIC CIPHER MODEL  \nA symmetric encryption scheme has five ingredients (Figure 2.1):  \n \n\u2022 Plaintext:  This is the original intelligible message or data that is fed into the  algorithm as \ninput.  \n\u2022 Encryption algorithm:  The encryption algorithm performs various substitutions and \ntransformations on the  plaintext.  \n\u2022 Secret key:  The secret key is also input to the encryption algorithm. The key  is a value \nindependent of the plaintext and of the algorithm. The algorithm  will produce a different \noutput depending on the specific key being used at the  time. The exact substitutions and \ntransformations performed by the algorithm  depend on the key.  \n\u2022 Ciphertext:  This is the scrambled message produced as output. It depends on  the plaintext \nand the secret key. For a given message, two different keys will  produce two different \nciphertexts. The ciphertext is an apparently random  stream of data and, as it stands, is \nunintelligible.  \n\u2022 Decryption algorithm:  This is essentially the encryption algorithm run in reverse . It takes \nthe ciphertext and the secret key and produces the original  plaintext.  \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nThere are two requirements for secure use of conventional encryption:  \n 1.  We need a strong encryption algorithm. At a minimum, we would like the algorithm  to be such \nthat an opponent who knows the algorithm and has  access to one or more ciphertexts would be \nunable to decipher the ciphertext  or figure out the key. This requirement is usually stated in a \nstronger form:  The opponent should be unable to decrypt ciphertext or discover the key even  if he \nor she is in possession of a number of ciphertexts together with the plaintext that produced each  \nciphertext.  \n 2.  Sender and receiver must have obtained copies of the secret key in a secure  fashion and must \nkeep the key secure. If someone can discover the key and  knows the algorithm, all communication \nusing this key is readable.  \nWe assume that it is impractical to decrypt a message on the basis of the ciphertext plus knowledge \nof the encryption/decryption algorithm. In other words, we  do not need to keep the algorithm \nsecret; we need to keep only the key secret. This  feature of symmetric encryption is what makes \nit feasible for widespread use. The fact  that the algorithm need not be kept secret means that \nmanufacturers can and have  developed low -cost chip implementations of data encryption \nalgorithms. These chips  are widely available and incorporated into a number of products. With the \nuse of symmetric encryption, the principal security problem is maintaining the secrecy of the  key. \n \nLet us take  A closer look at  the essential elements of a  symmetric  encryption scheme, using Figure \n2.2. A source produces a message in  plaintext,  X = [X1, X2, c, XM]. The M elements of X are \nletters in some finite alphabet.  \nTraditionally, the alphabet usually consisted of the 26 capital letters. Nowadays,  the binary \nalphabet {0, 1} is typically used. For encryption, a key of the form  K = [K1, K2, c, KJ] is \ngenerated. If the key is generated at the message source,  then it must also be provided to the \ndestination by means of some secure channel.  Alternatively, a third party could generate the key \nand securely deliver it to both  source and destination.   \nWith the message X and the encryption key K as input, the encryption algorithm forms the \nciphertext  \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nY = [Y1, Y2, c, YN]. We can write this as  \n                                              Y = E(K, X)  \nThis notation indicates that Y is produced by using encryption algorithm E as a  function of the \nplaintext X, with the specific function determined by the value of  the key K.  The intended receiver, \nin possession of the key, is able to invert the  transformation:  \n                                                         X = D(K, Y)  \nAn opponent, observing Y but not having access to K or X, may attempt  to recover X or K or both \nX and K. It is assumed that the opponent knows the  encryption (E) and decryption (D) algorithms. \nIf the opponent is interested in only  this particular message, then the focus of the effort is to recover \nX by generating  a plaintext estimate X . Often, however, the opponent is interested in being able  \nto read future messages as well, in which case an attempt is made to recover K by  generating an \nestimate K . \nCryptography  \nCryptographic systems are characterized along three independent dimensions:  \n 1. The type of operations used for transforming plaintext to ciphertext . All encryption  \nalgorithms are based on two general principles: substitution, in  which each element in the plaintext \n(bit, letter, group of bits or letters) is  mapped into another element, and transposition, in which \nelements in the  plaintext are rearranged. The fundamental requirement is that no information be \nlost (i.e., that all operations are reversible). Most systems, referred to as  product systems, involve \nmultiple stages of substitutions and transpositions.  \n 2.  The number of keys used . If both sender and receiver use the same key, the  system is referred \nto as symmetric, single -key, secret -key, or conventional encryption . If the sender and receiver use \ndifferent keys, the system is referred  to as asymmetric, two -key, or public -key encryption.  \n 3.  The way in which the plaintext is processed . A block cipher processes the  input one block \nof elements at a time, producing an output block for each  input block. A stream cipher processes \nthe input elements continuously, producing  output one element at a time, as it goes along.  \n \n. Cryptanalysis and Brute -Force Attack  \nTypically, the objective of attacking an encryption system is to recover the key in  use rather than \nsimply to recover the plaintext of a single ciphertext. There are two  general approaches to attacking \na conventional encryption scheme:  \n  \n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \n\u2022 Cryptanalysis:  Cryptanalytic attacks rely on the nature of the algorithm plus  perhaps some \nknowledge of the general characteristics of the plaintext or  even some sample plaintext \u2013ciphertext \npairs. This type of attack exploits the  characteristics of the algorithm to attempt to deduce a \nspecific plaintext or to  deduce the key being used.  \n  \n\u2022 Brute -force attack:  The attacker tries every possible key on a piece of ciphertext until an \nintelligible translation into plaintext is obtained. On average, half  of all possible keys must be tried \nto achieve  success.   \nIf either type of attack succeeds in deducing the key, the effect is catastrophic:  All future and past \nmessages encrypted with that key are compromised.  We first consider cryptanalysis and then \ndiscuss brute -force attacks.  \nTable 2.1 summarizes the various types of cryptanalytic attacks based on the  amount of \ninformation known to the cryptanalyst. The most difficult problem is  presented when all that is \navailable is the ciphertext only. In some cases, not even  the encryption algorithm is known, but in \ngeneral, we can assume that the opponent does know the algorithm used for encryption. One \npossible attack under these  \n \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nA brute -force attack involves trying every possible key until an intelligible  translation of the \nciphertext into plaintext is obtained. On average, half of all possible keys must be tried to achieve \nsuccess. That is, if there are  X different keys, on  average an attacker would discover the actual key \nafter X>2 tries. It is important to note that there is more to a brute -force attack than simply running \nthrough all possible keys. Unless known plaintext is provided, the analyst must be able to \nrecognize  plaintext as plaintext. If the message is just plain text in English, then the result pops  \nout easily, although the task of recognizing English would have to be automated. If  the text \nmessage has been compressed before encryption, then recognition is more  difficult.  An if the  \nMessage  is some  More general type  of data,  such as  a numerical file, and this has been compressed, \nthe problem becomes even more difficult to  automate. Thus, to supplement the brute -force \napproach, some degree of  knowledge about the expected plaintext is needed, and some means of  \nautomatically  distinguishing plaintext from garble is also  needed.  \nSUBSTITUTION TECHNIQUES  \nThe two basic building blocks of all encryption techniques are substitution  and transposition. We \nexamine these in the next two sections. Finally, we discuss a  system that combines both \nsubstitution and transposition.  A substitution technique is one in which the letters of plaintext are \nreplaced by  other letters or by numbers or symbols.   If the plaintext is viewed as a sequence of \nbits, then substitution involves replacing plaintext bit patterns with ciphertext bit patterns.  \nCaesar Cipher  \nThe earliest known, and the simplest, use of a substitution cipher was by Julius  Caesar. The Caesar \ncipher involves replacing each letter of the alphabet with the  letter standing three places further \ndown the alphabet. For example,  \n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \n \n \n \n \nIf it is known that a given ciphertext is a Caesar cipher, then a brute -force cryptanalysis is easily \nperformed: simply try all the 25 possible keys. Figure 2.3  shows the results of applying this \nstrategy to the example ciphertext. In this case, the  plaintext leaps out as occupying the third line.  \nThree important characteristics of this problem enabled us to use a brute  force  cryptanalysis:  \n 1.  The encryption and decryption algorithms are known.  \n 2.  There are only 25 keys to try.  \n 3.  The language of the plaintext is known and easily recognizable.  \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \n \n \nMonoalphabetic Ciphers  With only 25 possible keys, the Caesar cipher is far from secure. A \ndramatic increase  in the key space can be achieved by allowing an arbitrary substitution. Before \nproceeding, we define the term  permutation. A  permutation  of a finite set of elements  S is an \nordered sequence of all the elements of  S, with each element appearing exactly  once. For example, \nif S = {a, b, c}, there are six permutations of S:  \n                                                  abc, acb, bac, bca, cab, cba  \nIn general, there are n! permutations of a set of n elements, because the first  element can be  chosen \nin one of n ways, the second in n - 1 ways, the third in n \u2013 2 ways, and so on.  \nRecall the assignment for the Caesar cipher:  \nplain:  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z  \ncipher: D E F G H I J K L M N O P Q R S T U V W X Y Z A B C  \n \nThere is, however, another line of attack. If the cryptanalyst knows the nature  of the plaintext  (e.g., \nnoncompressed English text), then the analyst can exploit the  regularities of the language. To see \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nhow such a cryptanalysis might proceed, we give  a partial example here that is adapted from one \nin [SINK09]. The ciphertext to be  solved is  \nUZQSOVUOHXMOPVGPOZPEVSGZWSZOPFPESXUDBMETSXAIZ  \nVUEPHZHMDZSHZOWSFPAPPDTSVPQUZWYMXUZUHSX  \nEPYEPOPDZSZUFPOMBZWPFUPZHMDJUDTMOHMQ  \nAs a first step, the relative frequency of the letters can be determined and  compared to a standard \nfrequency distribution for English, such as is shown in  Figure 2.5 (based on [LEWA00]). If the \nmessage were long enough, this technique  alone might be sufficient, but because this is a relatively \nshort message, we cannot  expect an exact match. In any case, the relative frequencies of the letters \nin the ciphertext  (in percentages) are as follows:  \n \n \nComparing this breakdown with Figure 2.5, it seems likely that cipher letters P  and Z are the \nequivalents of plain letters e and t, but it is not certain which is which.  The letters S, U, O, M,  and \nH are all of relatively high frequency and probably correspond to plain letters from the set {a, h, \ni, n, o, r, s}. The letters with the lowest  frequencies (namely, A, B, G, Y , I, J) are likely included in \nthe set {b, j, k, q, v, x,  z}. \nThere are a number of ways to proceed at this point. We could make some  tentative assignments  \nand start to fill in the plaintext to see if it looks like a  reasonable  \u201cskeleton\u201d of a message. A more \nsystematic approach is to look for other  regularities.  \nFor example, certain words may be known to be in the text. Or we could look  for repeating \nsequences of cipher letters and try to deduce their plaintext  equivalents.   \nA powerful tool is to look at the frequency of two -letter combinations, known  as diagrams . A \ntable similar to Figure 2.5 could be drawn up showing the relative  frequency of diagrams . The \nmost common such diagram  is th. In our ciphertext, the most  common diagram  is ZW, which \nappears three times. So we make the correspondence  of Z with t and W with h. Then, by our earlier \nhypothesis, we can equate P with e.  Now notice that the sequence ZWP appears in the ciphertext, \nand we can translate  that Sequence  as \u201cthe.\u201d  This is the most  Frequent  trigram  (three -letter  \ncombination)  in English, which seems to indicate that we are on the right  track.  \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nNext, notice  the sequence ZWSZ  in the  first line. We do  not know that  these  four letters form a \ncomplete word, but if they do, it is of the form th_t. If so,  S equates with  a. \n \n \n \nPlayfair Cipher  \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nThe best -known multiple -letter encryption cipher is the Playfair, which treats  diagrams  in the  \nplaintext as single units and translates these units into ciphertext  diagrams .  \n The Playfair algorithm is based on the use of a 5 * 5 matrix of letters constructed  using  a keyword.  \nHere  is an example,  solved  by Lord  Peter  Wimsey  in Dorothy Sayers\u2019s  \nHave His  Carcase:  \n \n \nIn this case, the keyword is monarchy. The matrix is constructed by filling  in the letters of the \nkeyword (minus duplicates) from left to right and from top to  bottom, and then filling in the \nremainder of the matrix with the remaining letters in  alphabetic order. The letters I and J count as \none letter. Plaintext is encrypted two  letters at a time, according to the following rules:  \n 1.  Repeating plaintext letters that are in the same pair are separated with a filler  letter, such as x, \nso that balloon would be treated as ba lx lo on.  \n 2.  Two plaintext letters that fall in the same row of the matrix are each replaced  by the letter to \nthe right, with the first element of the row circularly following  the last. For example, ar is \nencrypted as RM.  \n 3.  Two plaintext letters that fall in the same column are each replaced by the  letter beneath, with \nthe top element of the column circularly following the last.  \nFor example, mu is encrypted as CM.  \n4. Otherwise, each plaintext letter in a pair is replaced by the letter that lies in  its own row and the \ncolumn occupied by the other plaintext letter. Thus, hs  becomes BP and ea becomes IM (or JM, \nas the encipherer wishes).  \n \nHill Cipher  \nAnother interesting multilettered  cipher is the Hill cipher, developed by the mathematician Lester \nHill in  1929.  Concepts  from Linear Algebra  Before describing the Hill cipher, let us briefly  review \nsome terminology from linear algebra. In this discussion, we are concerned  with matrix arithmetic \nmodulo 26. For the reader who needs a refresher on matrix  multiplication and inversion, see \nAppendix E.  We define the inverse M   of a square matrix M by the equation  M(M ^- 1) (M^-1)M \n= I, where I is the identity matrix. I is a square matrix that is all  zeros except for ones along the \n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nmain diagonal from upper left to lower right. The  inverse of a matrix does not always exist, but \nwhen it does, it satisfies the preceding  equation. For example,  \n \nTo explain how the inverse of a matrix is computed, we begin with the concept of determinant. \nFor any square matrix (m * m), the determinant equals the sum of  all the products that can be \nformed by taking exactly one element from each row  and exactly one element from each column, \nwith certain of the product terms preceded by a minus sign. For a 2 * 2 matrix,  \n \n \n \n \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \n \nTHE HILL ALGORITHM : \n This encryption algorithm takes m successive plaintext letters and substitutes for them  m \nciphertext letters. The substitution is  determined  by m linear equations in which each character is \nassigned a numerical value  (a =  0,  b =  1, c, z =  25). For m = 3, the system can be described as  \n \n \n \nwhere C and P are row vectors of length 3 representing the plaintext and ciphertext,  and K  is a 3 \n* 3 matrix representing the encryption key. Operations are performed  mod 26.  \nFor example, consider the plaintext \u201cpaymoremoney\u201d and use the encryption  \nkey \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \n \n \n \nPolyalphabetic Ciphers  \nAnother way to improve on the simple monoalphabetic technique is to use different \nmonoalphabetic substitutions as one proceeds through the plaintext  message.  The general name \nfor this approach is  polyalphabetic substitution  cipher. All these  techniques have the following \nfeatures in  \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \ncommon:  \n 1.  A set of related monoalphabetic substitution rules is used.  \n 2.  A key determines which particular rule is chosen for a given transformation.  \nVigen\u00e8re Cipher The best known, and one of the simplest, polyalphabetic cipher is  the Vigen\u00e8re \ncipher. In this scheme, the set of related monoalphabetic substitution rules consists of the 26 Caesar \nciphers with shifts of 0 through 25. Each cipher is  denoted by a key letter, which is the ciphertext \nletter that substitutes for the plaintext letter  a. Thus, a Caesar cipher with a shift of 3 is denoted by \nthe key value 3.  \nWe can express the Vigen\u00e8re cipher in the following manner. Assume a   sequence of plaintext \nletters P = p0, p1, p2, c, pn - 1 and a key consisting of the  sequence of letters K = k0, k1, k2, c, \nkm - 1, where typically m < n. The sequence of  ciphertext letters C = C0, C1, C2, c, Cn - 1 is \ncalculated as follows:  \nC= C0, C1, C2, c, Cn - 1 = E(K, P) = E[(k0, k1, k2, c, km - 1), (p0, p1, p2, c, pn - 1)] \n= (p0 + k0) mod 26, (p1 + k1) mod 26, c, (pm - 1 + km - 1) mod 26,  \n         (pm + k0) mod 26, (pm + 1 + k1) mod 26, c, (p2m - 1 + km - 1) mod 26 \u2026. \nA general equation of the encryption  process is  \nCi = (pi + ki mod m) mod 26  \nSimilarly, decryption is a generalization of  \npi = (Ci - ki mod m) mod 26  \nTo encrypt a message, a key is needed that is as long as the message. Usually, the key is a repeating \nkeyword. For example, if the keyword is deceptive , the message \u201cwe are discovered save \nyourself\u201d  is encrypted as  \n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \n \n \nVernam Cipher  \nThe ultimate defense against such a cryptanalysis is to choose a  keyword that is as long as the \nplaintext and has no statistical relationship to it. Such  a system was introduced by an AT&T \nengineer named Gilbert Vernam in 1918.  \n \nThus, the ciphertext is generated by performing the bitwise XOR of the plain - text and the key. \nBecause of the properties of the XOR, decryption simply involves  the same bitwise operation:  \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \npi = ci - ki \n \nOne-Time Pad  \nAn Army Signal Corp officer, Joseph Mauborgne, proposed an improvement to the  Vernam cipher \nthat yields the ultimate in security. Mauborgne suggested using a  random key that is as long as the \nmessage, so that the key need not be repeated. In  addition, the key is to be used to encrypt and \ndecrypt a single message, and then is  discarded. Each new message requires a new key of the same \nlength as the new message. Such a scheme, known as a  one-time pad, is unbreakable. It produces \nrandom  output that bears no statistical relationship to the plaintext. Because the ciphertext  contains \nno information whatsoever about the plaintext, there is simply no way to  break the  code.  \nAn example should illustrate our point. Suppose that we are using a  Vigen\u00e8re scheme with 27 \ncharacters in which the twenty -seventh character is the  space character, but with a one -time key \nthat is as long as the message. Consider  the ciphertext  \n \n \nIn theory, we need look no further for a cipher. The one -time pad offers complete security but, in \npractice, has two fundamental  difficulties:  \n1. There is the practical problem of making large quantities of random keys.  Any heavily used \nsystem might require millions of random characters on a regular basis. Supplying truly \nrandom characters in this volume is a  significant task.  \n2. Even more daunting is the problem of key distribution and protection. For  every message \nto be sent, a key of equal length is needed by both sender and  receiver. Thus, a mammoth \nkey distribution problem exists.  \n \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \n \nTraditional block cipher structure  \nStream Ciphers and Block Ciphers  \nA stream cipher  is one that encrypts a digital data stream one bit or one byte at  a time. Examples \nof classical stream ciphers are the autokeyed Vigen\u00e8re cipher  and the Vernam cipher. In the ideal \ncase, a one -time pad version of the Vernam  cipher would be used (Figure 2.7), in which the \nkeystream (ki) is as long as the  plaintext bit stream (pi). If the cryptographic keystream is random, \nthen this cipher  is unbreakable by any means other than acquiring the keystream. However, the  \nkeystream must be provided to both users in advance via some independent and  secure channel. \nThis introduces i nsurmountable logistical problems if the intended  data traffic is very large.  \nAccordingly, for practical reasons, the bit -stream generator must be  implemented as an \nalgorithmic procedure, so that the cryptographic bit stream  can be produced by both users. In this \napproach (Figure 3.1a), the bit -stream  generator is a key -controlled algorithm and must produce a \nbit stream that is  cryptographically strong. That is, it must be computationally impractical to  \npredict future portions of the bit stream based on previous portions of the bit  stream. The two users \nneed only share the generatin g key, and each can produce  the keystream  \nA block cipher is one in which a block of plaintext is treated as a whole  And used to produce a \nciphertext block of equal length. Typically, a block size of  64 or 128 bits is used. As with a stream \ncipher, the two users share a symmetric  Encryption key (Figure 3.1b). Using some of the modes \nof operation explained  In Chapter 6, a block cipher can be used to achieve the same effect as a \nstream  Cipher.  \nFar more effort has gone into analyzing block ciphers. In general, they seem  Applicable to \na broader range of applications than stream ciphers. The vast majority of network -based  symmetric \ncryptographic applications make use of  Block  Ciphers.  Accordingly,  The concern  In this  Chapter, \nand in  Our discussions  Throughout  The book of symmetric encryption, will primarily focus on \nblock  Ciphers.   \nMotivation for the Feistel Cipher Structure   \nA block cipher operates on a plaintext block of n bits to produce a ciphertext  Block of n bits. There \nare 2  N Possible different plaintext blocks and, for the  Encryption to be reversible (i.e., for \ndecryption to be possible), each must produce  A Unique  Ciphertext  Block.  Such  A Transformation  \n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nIs Called  Reversible,  Or non-singular. The following examples illustrate non -singular and singular \ntransformations for  n= 2.  \n \n \nIn the latter case, a ciphertext of 01 could have been produced by one of two plaintext blocks. So \nif we limit ourselves to reversible mappings, the number of different  transformations is  2^n 2! \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \n \nFigure 3.2 illustrates the logic of a general substitution cipher for n = 4.  A 4-bit input produces \none of 16 possible input states, which is mapped by the substitution cipher into a unique one of 16 \npossible output states, each of which is  represented by 4  ciphertext bits. The encryption and \ndecryption mappings can be defined  by a tabulation, as shown in Table 3.1. This is the most general \nform of block cipher  and can be used to define any reversible mapping between plaintext and \nciphertext.  \n \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nFeistel refers to this as the ideal block cipher, because it allows for the maximum  number of \npossible encryption mappings from the plaintext block [FEIS75].  But there is a practical problem \nwith the  ideal block cipher. If a small block  size, such as n = 4, is used, then the system is equivalent \nto a classical substitution  cipher. Such systems, as we have seen, are vulnerable to a statistical \nanalysis of the  plaintext. This weakness is not inherent in the use of a substitution cipher but rather  \nresults from the use of a small block size. If n is sufficiently large and an arbitrary reversible \nsubstitution between plaintext and ciphertext is allowed, then the  Statistical  characteristics  of the \nsource  plaintext  are masked to  such an extent  that this type of cryptanalysis is  infeasible.  \nAn arbitrary  reversible  substitution  cipher  (the ideal  block  cipher)  for a large  block size is not \npractical, however, from an implementation and  performance  point of view. For such a  \ntransformation, the mapping itself constitutes th e key. \nConsider again  Table 3.1,  which defines  one particular  reversible  mapping  from plaintext to  \nciphertext for  n = 4. The mapping can be defined by the entries in the  second column, which show \nthe value of the ciphertext for each plaintext block.  \nThis, in essence, is the key that determines the specific mapping from among all possible \nmappings. In this case, using this straightforward method of defining the key,  the required key \nlength is  (4 bits) * (16 rows) = 64 bits. In general, for an n -bit ideal block cipher, the length of \nthe key defined in this fashion is n * 2   bits. For a  64-bit block, which is a desirable length to \nthwart statistical  attacks, the required  key length is 64 * 2 n 64 bits. In considering these \ndifficulties, Feistel points out that what is needed is an   7021 = 2 \u2248 10 approximation to the \nideal block cipher system for large n, built up out of components that  are easily  realizable \n[FEIS75].  \nBut before  turning to  Feistel\u2019s approach,  let us make one other observation. We could use the \ngeneral block  substitution  cipher but, to make its implementation tractable, confine ourselves to \na subset  of the 2 n ! possible reversible mappings. For example, suppose we define the mapping  \nin terms of a set of linear equations. In the case of n = 4, we have  \ny1 = k11x1 + k12x2 + k13x3 + k14x4  \ny2 = k21x1 + k22x2 + k23x3 + k24x4  \ny3 = k31x1 + k32x2 + k33x3 + k34x4  \ny4 = k41x1 + k42x2 + k43x3 + k44x4  \n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nwhere the xi are the four binary digits of the plaintext block, the yi are the four  binary digits of \nthe ciphertext block, the kij are the binary coefficients, and arithmetic is mod 2. The key size is \njust n, in this case 16 bits. The danger with this kind of  formulation is that it may be vulnerable to \ncryptanalysis by an attacker that is aware  of the structure of the algorithm. In this example, what \nwe have is essentially the  Hill cipher discussed in Chapter 2, applied to binary data rather than \ncharacter s. As  we saw in Chapter 2, a simple linear system such as this is quite vulnerable.   \n \nThe Feistel Cipher  \nFeistel proposed [FEIS73] that we can approximate the ideal block cipher by utilizing  the concept \nof a product cipher, which is the execution of two or more simple ciphers  in sequence in such a \nway that the final result or product is cryptographically stronger  than any of the component \nciphers. The essence of the approach is to develop a block  cipher with a key length of k bits and a \nblock length of n bits, allowing a total of 2  possible transformations, rather than the 2k! \ntransformations available with the ideal  block cipher.  \nIn particular, Feistel proposed the use of a cipher that alternates substitutions  and permutations,  \nwhere these terms are defined as follows:  \n\u2022 Substitution:  Each plaintext element or group of elements is uniquely replaced  by a \ncorresponding ciphertext element or group of elements.  \n\u2022 Permutation:  A sequence of plaintext elements is replaced by a permutation  of that sequence. \nThat is, no elements are added or deleted or replaced in the  sequence, rather the order in which the \nelements appear in the sequence is  changed.  \nIn fact, Feistel\u2019s is a practical application of a proposal by Claude Shannon  to develop a product \ncipher that alternates confusion and diffusion functions  [SHAN49].  \nDiffusion an d Confusion   \nThe terms diffusion and confusion were introduced by  Claude Shannon to capture the two basic \nbuilding blocks for any cryptographic system [SHAN49]. Shannon\u2019s concern was to thwart \ncryptanalysis based on statistical analysis. The reasoning is as follows. Assume the attacker has \nsome knowledge  of the statistical characteristics of the plaintext. For example, in a human -\nreadable  message in some language, the frequency distribution of the various letters may be  words \nor phrases likely to appear in the message ( probable  words). If these statistics are in any way \n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nreflected in the ciphertext, the cryptanalyst  may be able to deduce the encryption key, part of the \nkey, or at least a set of keys  likely to contain the exact key. In what Shannon refers to as a strongly \nideal cipher,  all statistics of the ciphertext are independent of the particular key used. The arbitrary \nsubstitution cipher that we discussed previously (Figure 3.2) is such a cipher,  but as we have seen, \nit is impractical.  \n \nOther than recourse to ideal systems, Shannon suggests two methods for frustrating  statistical \ncryptanalysis: diffusion and confusion. In diffusion, the statistical  structure of the plaintext is \ndissipated into long -range statistics of the  ciphertext. This is achieved by having each plaintext \ndigit affect the value of many  ciphertext digits; generally, this is equivalent to having each \nciphertext digit be  affected by many plaintext digits. An example of diffusion is to encrypt a \nmessage  M = m1, m2, m3, . . . of characters with an averaging operation:  \n \nadding k successive letters to get a ciphertext letter yn. One can show that the statistical structure \nof the plaintext has been dissipated. Thus, the letter frequencies in  the ciphertext will be more \nnearly equal than in the plaintext; the diagram frequencies will also be more nearly equal, and so \non. In a binary block cipher, diffusion can  be achieved by repeatedly performing some permutation \non the data followed  by applying a function to that permutation; the effect is that bits from different  \npositions in the original plaintext contribute to a single bit of  ciphertext.  \n \nEvery block cipher involves a transformation of a block of plaintext into a  block of ciphertext, \nwhere the transformation depends on the key. The mechanism  of diffusion seeks to make the \nstatistical relationship between the plaintext and ciphertext as complex as possible in order to th e \nwart attempts to deduce the key. On  the other hand, confusion  seeks to make the relationship \nbetween the statistics of  the ciphertext and the value of the encryption key as complex as possible, \nagain to  thwart attempts to discover the key. Thus, even if the attacker can get some handle  on the \nstatistics of the ciphertext, the way in which the key was used to produce that  ciphertext is so \ncomplex as to make it difficult to deduce the key. This is achieved by  the use of a complex \nsubstitution algorithm. In contrast, a simple linear substitution  function would add littl e confusion.  \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \n \nFeistel Cipher Structure   \n \nThe left -hand side of Figure 3.3 depicts the structure  proposed by Feistel. The inputs to the \nencryption algorithm are a plaintext block of  length 2w bits and a key K. The plaintext block is \ndivided into two halves, L0 and R0.  The two halves of the data pass through n rounds of processing \nand then combine to produce  the ciphertext block. Each round i has as inputs Li - 1 and Ri - 1 \nderived from  the previous round, as well as a subkey Ki derived from the overall K. In general,  \nthe subkeys Ki are different from K and from each other. In Figure 3.3, 16 rounds  are used, \nalthough any number of rounds could be implemented.  \n \nAll rounds have the same structure. A substitution is performed on the left half  of the data. This is \ndone by applying a round function F to the right half of the data  and then taking the exclusive -OR \nof the output of that function and the left half of the  data. The round function has the same general \nstructure for each round but is parameterized by the round subkey  Ki. Another way to express this \nis to say that F is a  function of right -half block of  w bits and a subkey of  y bits, which produces \nan output  value  of length w bits: F(REi, Ki + 1). Following this substitution, a permutation is \nperformed  that consists of the interchange of the two halves of the data.   This structure is a \nparticular form of the substitution -permutation network (SPN) proposed by  Shannon.  \n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \n \nThe exact realization of a Feistel network depends on the choice of the following parameters and \ndesign  features:  \nBlock size:  Larger block sizes mean greater security (all other things being  equal) but reduced \nencryption/decryption speed for a given algorithm. The  greater security is achieved by greater \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \ndiffusion. Traditionally, a block size of  64 bits has been considered a reasonable tradeoff and was \nnearly universal in  block cipher design. However, the new AES uses a 128 -bit block size.  \nKey size:  Larger key size means greater security but may decrease encryption/  decryption speed. \nThe greater security is achieved by greater resistance to  brute -force attacks and greater confusion. \nKey sizes of 64 bits or less are now  widely considered to be inadequate, and 128 bits has become \na common size.  \nNumber of rounds : The essence of the Feistel cipher is that a single round  offers inadequate \nsecurity but that multiple rounds offer increasing security.  A typical size is 16 rounds.  \nSubkey generation algorithm : Greater complexity in this algorithm should  lead to greater \ndifficulty of cryptanalysis.  \nRound function F:  Again, greater complexity generally means greater resistance to  cryptanalysis.  \nThere are two other considerations in the design of a Feistel cipher:  \nFast software encryption/decryption : In many cases, encryption is embedded in  applications or \nutility functions in such a way as to preclude a hardware implementation. Accordingly, the speed \nof execution of the algorithm becomes  a concern.  \nEase of analysis : Although we would like to make our algorithm as difficult as  possible to \ncryptanalyze, there is great benefit in making the algorithm easy to  analyze. That is, if the \nalgorithm can be concisely and clearly explained, it is  easier to analyze that algorithm for \ncryptanalytic vulnerabilities and therefore  develop a higher level of assurance as to its strength. \nDES, for example, does  not have an easily analyzed functionality.  \n \nFeistel De cryption Algorithm   \nThe process of decryption with a Feistel cipher  is essentially the same as the encryption process. \nThe rule is as follows: Use the  ciphertext as input to the algorithm but use the subkeys Ki in reverse \norder. That  is, use Kn in the first round, Kn - 1 in the second round, and so on, until K1 is used in  \nthe last round. This is a nice feature, because it means we need not implement two  different \nalgorithms; one for encryption and one for decryption.  \nTo see that the same algorithm with a reversed key order produces the correct  result, Figure  3.3 \nshows the encryption process going down the left -hand side and the  decryption process going up \n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nthe right -hand side for a 16 -round algorithm. For clarity,  we use the notation LEi and REi for data \ntraveling through the encryption algorithm  and LDi and RDi for data traveling through the \ndecryption algorithm. The diagram  indicates that, at every round, the intermediate value of the \ndecryption process is  equal to the corresponding value of the encryption process with the two \nhalves of the  value swapped. To put this another way, let the output of the ith encryption round be  \nLEi REi (LEi concatenated with R Ei). Then the corresponding output of the (16 \u2013 i) th decryption \nround is REi  LEi or, equivalently, LD16 \u2013 I RD16 - i. \nLet us walk through Figure 3.3 to demonstrate the validity of the preceding  assertions. After  the \nlast iteration of the encryption process, the two halves of the  output are swapped, so that the \nciphertext is RE16  LE16. The output of that round  is the ciphertext. Now take that ciphertext and \nuse it as input to the same algorithm.  The input to the first round is RE16  LE16, which is equal to \nthe 32 -bit swap of the  output of the sixteenth round of the encryption process.  \nNow we would like to show that the output of the first round of the decryption  process is equal to \na 32-bit swap of the input to the sixteenth round of the encryption  process. First, consider the \nencryption process. We see that  \n \nThus, we have LD1 = RE15 and RD1 = LE15. Therefore, the output of the first  round of the \ndecryption process is RE15  LE15, which is the 32 -bit swap of the input  to the sixteenth round of \nthe encryption. This correspondence holds all the way  through the 16 iterations, as is easily shown. \nWe can cast this process in general  terms. For the ith iteration of the encryption algorithm,   \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \n \nThus, we have described the inputs to the ith iteration as a function of the outputs, and  these \nequations confirm the assignments shown in the right -hand side of Figure 3.3.   \nFinally, we see that the output of the last round of the decryption process is  RE0 LE0. A \n32-bit swap recovers the original plaintext, demonstrating the validity of the Feistel decryption \nprocess.   \nNote that the derivation does not require that F be a reversible function.  To see this, take \na limiting case in which F produces a constant output (e.g., all ones)  regardless of the values of its \ntwo arguments. The equations still hold.  \n \nTo help clarify the preceding concepts, let us look at a specific example  (Figure 3.4  and focus on \nthe fifteenth round of encryption, corresponding to the second round of decryption. Suppose that \nthe blocks at each stage are 32 bits (two  16-bit halves) and that the key size is 24 bits. Suppose \nthat at the end of encryption  round  fourteen, the value of the intermediate block (in hexadecimal) \nis DE7F03A6.  Then  = DE7F and RE14 = 03A6. Also assume that the value of K15 is 12DE52.  \nAfter round 15, we have LE15 =  03A6 and RE15 = F(03A6, 12DE52) - DE7F.  Now let\u2019s look at \nthe decryption. We assume that LD= RE and RD= LE,  as shown in Figure 3.3, and we want to \ndemonstrate that LD2 = RE14 and RD2 = LE14.  So, we start with LD1 = F(03A6, \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \n12DE52) - DE7F and RD1 = 03A6. Then,  from Figure 3.3, LD2 = 03A6 = RE14 and RD2 = \nF(03A6, 12DE52) -  [F(03A6,  12DE52) - DE7F] = DE7F = LE14.  \n \n \nThe data Encryption  standard  \nUntil the introduction of the Advanced Encryption Standard (AES) in 2001, the  Data Encryption \nStandard (DES) was the most widely used encryption scheme.  DES was issued in 1977 by the \nNational Bureau of Standards, now the National  Institute of Standards and Technology (NIST), as \nFederal Information Processing  Standard 46 (FIPS PUB 46). The algorithm itself is referred to as \nthe Data  \nEncryption Algorithm (DEA).  \n For DEA, data are encrypted in 64 -bit blocks using  a 56-bit key. The algorithm transforms 64 -bit \ninput in a series of steps into a 64 -bit output. The same steps, with the same key, are used to reverse \nthe encryption.  Over the years, DES became the dominant symmetric encryption algorithm,  \nespecially in financial applications. In 1994, NIST reaffirmed DES for federal use  for another five \nyears; NIST recommended the use of DES for applications other  than the protection of classified \ninformation.  \nDES Encryption  \nThe overall scheme for DES encryption is illustrated in Figure 3.5. As with any encryption scheme, \nthere are two inputs to the encryption function: the plaintext to  be encrypted and the key. In this \ncase, the plaintext must be 64 bits in length and the  key is 56 bits in length.  Looking at the left -\nhand side of the figure, we can see that the processing  of the plaintext proceeds in three phases. \nFirst, the 64 -bit plaintext passes through  an initial permutation (IP) that rearranges the bits to \nproduce the permuted input.  \nThis is followed by a phase consisting of sixteen rounds of the same function, which  involves both \npermutation and substitution functions. The output of the last (sixteenth) round consists of 64 bits \nthat are a function of the input plaintext and the  key. The left and right halves of the output are \nswapped to produce the  preoutput.  \n \n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nFinally, the preoutput is passed through a permutation  [IP] that is the inverse of  the initial \npermutation function, to produce the 64 -bit ciphertext. With the exception of the initial and final \npermutations, DES has the exact structure of a Feistel  cipher, as shown in Figure  3.3. \nThe right -hand portion of Figure 3.5 shows the way in which the 56 -bit key is  used. Initially, the \nkey is passed through a permutation function. Then, for each of  the sixteen rounds, a  subkey  (Ki) \nis produced by the combination of a left circular  shift and a permutation.  The permutation function  \nis the same for  each round, but a  different subkey is produced because of the repeated shifts of the \nkey \nbits \n \n \n \n \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nDES Decryption  \nAs with any Feistel cipher, decryption uses the same algorithm as encryption, except  that the \napplication of the subkeys is reversed. Additionally, the initial and  final permutations are reversed.  \nA DES EXAMPLE : \nWe now work through an example and consider some of its implications. Although  you are not \nexpected to duplicate the example by hand, you will find it informative  to study the hex patterns \nthat occur from one step to the next.  For this example, the plaintext is a hexadecimal palindrome. \nThe plaintext,  key, and resulting ciphertext are as follows:  \n \n \nResults  \nTable 3.2 shows the progression of the algorithm. The first row shows the 32 -bit values of the left \nand right halves of data after the initial permutation. The next 16  rows show the results after each \nround. Also shown is the value of the 48 -bit subkey  generated for each round. Note that Li = Ri - \n1. The final row shows the left - and right -hand values after the inverse initial permutation. These \ntwo values combined  form the ciphertext.  \n \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nTHE STRENGTH OF DES  \nSince its adoption as a federal standard, there have been lingering concerns about  the level of \nsecurity provided by DES. These concerns, by and large, fall into two  areas: key size and the nature \nof the algorithm.  The Use of 56 -Bit Keys  With a key length of 56 bits, there are 2  possible keys, \nwhich is approximately  7.2 * 10  ^16 keys. Thus, on the face of it, a brute -force attack appears \nimpractical.  Assuming that, on average, half the key space has to be searched, a single machine  \nperforming one DES encryption per microsecond would take more than a thousand  years to break \nthe cipher.  However, the assumption of one encryption per  microsecond is overly conservative. As \nfar back as 1977, Diffie and Hellman postulated that the technology  existed to build a parallel \nmachine with 1 million encryption devices, each of which  could perform one encryption per \nmicrosecond [DIFF77]. This would bring  the average search time down to about 10 hours. The \nauthors estimated that the  cost would be about $20 million in 1977  dollars.  With current \ntechnology, it is not even necessary to use special, purpose -built hardware. Rather, the speed of \ncommercial, off -the-shelf processors threaten  The security of DES. A recent paper from Seagate \nTechnology [SEAG08] suggests that  a rate of 1 billion  key combinations per second is reasonable \nfor today\u2019s multicore computers. Recent offerings confirm this. Both Intel and AMD now  offer  \nhardware -based instructions to accelerate the use of AES. Tests run on a  contemporary multicore \nIntel machine resulted in an encryption rate of about half a  billion encryptions per second \n[BASU12]. Another recent analysis suggests that with  contemporary supercomputer technology, \na rate of  10 encryptions  per second is  reasonable [AROR12].  \nWith these results in mind, Table 3.5 shows how much time is required for  a brute -force \nattack for various key sizes. As can be seen, a single PC can break  DES in about a year; if multiple \nPCs work in parallel, the time is drastically shortened.  And today\u2019s  supercomputers  Should  be able \nto find  A key In about  an hour.  Key sizes of 128 bits or greater are effectively unbreakable using \nsimply a  brute force  approach. Even if  We managed  To speed  Up the attacking system  by A factor  \nof 1 trillion  (10^12), it would still take over 100,000 years to break a code using a  128-bit key.  \nFortunately, there are a number of alternatives to DES, the most important of  which are AES and \ntriple DES, discussed in Chapters 5 and 6, respectively.  \nThe Nature of the DES Algorithm  \nAnother concern is the possibility that cryptanalysis is possible by exploiting  the characteristics \nof the DES algorithm. The focus of concern has been on the  eight substitution tables, or S -boxes, \nthat are used in each iteration (described  in Appendix S). Because the design criteria for these \n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nboxes, and indeed for the  entire algorithm, were not made public, there is a suspicion that the \nboxes were  \n \n \nconstructed in such a way that cryptanalysis is possible for an opponent who knows  the \nweaknesses in the S -boxes. This assertion is tantalizing, and over the years a  number of regularities \nand unexpected behaviors of the S -boxes have been discovered. Despite this, no one has so far \nsucceeded  in discovering the supposed  fatal weaknesses in the  S-boxes.  \n \nTiming Attacks  \nWe discuss timing attacks in more detail in Part Two, as they relate to public -key  algorithms.  \nHowever, the issue may also be relevant for symmetric ciphers. In essence,  a timing attack is one \nin which information about the key or the plaintext is obtained  by observing how long it takes a \ngiven implementation to perform decryptions on  various ciphertexts. A timing attack exploits the \nfact that an encryption or decryption  algorithm often takes slightly different amounts of time on \ndifferent inputs. [HEVI99]  reports on an approach that yields the Hamming weight (number of \nbits equal to one)  of the secret key. This is a long way from knowing the actual key, but it is an \nintriguing  first step. The authors conclude that DES appears to be fairly resistant to a successful  \ntiming attack but suggest some avenues to explore. Although this is an interesting line  of attack, it \nso far appears unlikely that this technique will ever be successful against  DES or more powerful \nsymmetric ciphers such as triple DES and AES.  \n \n\n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \n \n \n \nBLOCK CIPHER DESIGN PRINCIPLES  \nAlthough much progress has been made in designing block ciphers that are cryptographically \nstrong, the basic principles have not changed all that much since the  work of Feistel and the DES \ndesign team in the early 1970s. In this section we look  at three critical aspects of block cipher \ndesign: the number of rounds, design of the  function F, and key  scheduling.  \n \nNumber of Rounds  \nThe cryptographic strength of a Feistel cipher derives from three aspects of the  design: the number \nof rounds, the function F, and the key schedule algorithm. Let  us look first at the choice of the \nnumber of rounds.  The greater the number of rounds, the more difficult it is to perform \ncryptanalysis, even for a relatively weak F. In general, the criterion should be that . The number of \nrounds is chosen so that known cryptanalytic efforts require  Greater  effort than a simple brute -\nforce key search attack. This criterion was certainly used  in the design of DES. Schneier \n[SCHN96] observes that for 16 -round DES, a  differential cryptanalysis attack is slightly less \nefficient than brute force: The differential  cryptanalysis attack requires  2^55.  If DES had 15 or \nfewer rounds, differential cryptanalysis would require less effort  than a brute -force key search.   \nThis criterion is attractive, because it makes it easy to judge the strength of  an algorithm \nand to compare different algorithms. In the absence of a cryptanalytic breakthrough, the strength \nof any algorithm that satisfies the criterion can be  judged solely on key  length.  \nDesign of Function F  \nThe heart of a Feistel block cipher is the function F, which provides the element  of confusion in a \nFeistel cipher. Thus, it must be difficult to \u201cunscramble\u201d the  substitution performed by F. One \nobvious criterion is that F be nonlinear, as we  discussed previously. The more nonlinear F, the \nmore difficult any type of cryptanalysis will be. There are several measures of nonlinearity, which \nare Beyond  the scope of this  book. In rough terms, the more difficult it is to approximate  F by a \nset of linear equations, the more nonlinear F  is. \n \nCEC, ISE DEPARTMENT,  MANGALORE  RANGANATHA K  \n CEC, ISE DEPARTMENT, MANGALORE  \nSeveral other criteria should be considered in designing F. We would like the  algorithm to \nhave good avalanche properties. Recall that, in general, this means that  a change in one bit  of the \ninput should produce  a change in many bits of  the output.  A more stringent version of this is the  \nstrict avalanche criterion  (SAC) [WEBS86],  which states that any output bit  j of an S -box (see \nAppendix S for a discussion of  S-boxes) should change with probability 1/2 when any single input \nbit i is inverted  for all i, j. Although SAC is expressed in terms of S -boxes, a similar criterion could  \nbe applied to F as a whole. This is important when considering designs that do not  include S -\nboxes.   \nAnother criterion proposed in [WEBS86] is the bit independence criterion  (BIC), which \nstates that output bits j and k should change independently when any  single input bit i is inverted \nfor all i, j, and k. The SAC and BIC criteria appear to  strengthen the effectiveness of the confusion \nfunction.  \n \nKey Schedule Algorithm  \nWith any Feistel block cipher, the key is used to generate one subkey for each  round. In \ngeneral, we would like to select subkeys to maximize the difficulty of  deducing individual subkeys \nand the difficulty of working back to the main key. No  general principles for this have yet been \npromulgated.  \n Adams suggests [ADAM94] that, at minimum, the key schedule should  guarantee \nkey/ciphertext Strict Avalanche Criterion and Bit Independence  Criterion.  \n \n"}